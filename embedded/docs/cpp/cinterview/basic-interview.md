## 基础面试题

> 此小节大部分内容均有 GPT 生成

<br>

### C++和 C 相比具有以下优势：

1. 面向对象：C++是一种面向对象的编程语言，它支持类、继承、多态等概念，可以更方便地编写面向对象的程序，提高代码的可维护性和复用性。

2. 类型安全：C++在类型检查上比 C 更严格，可以避免很多运行时错误。

3. 支持函数重载：C++支持函数重载，即可以定义多个同名函数，但是它们的参数列表必须不同，这样可以增加代码的灵活性和可读性。

4. 支持模板：C++支持模板，可以将类型参数化，提高代码的通用性和重用性。

5. 支持 STL：C++标准库提供了很多常用的数据结构和算法，如容器、迭代器、算法等，可以大大简化程序的开发。

6. 强大的内存管理：C++提供了丰富的内存管理功能，如 new/delete 操作符、构造函数/析构函数等，可以更加精确地控制程序的内存使用。

<br>

### 介绍一下哈希表

哈希表（Hash table）是一种高效的数据结构，用于实现映射（mapping）或关联数组（associative array）。哈希表基于哈希函数（Hash function）实现，通过将关键字（Key）映射到哈希表中的位置，可以快速地访问、查找、插入和删除元素。

哈希表的核心思想是将关键字映射到数组的索引上，这个映射过程由哈希函数负责完成。哈希函数将任意长度的输入（关键字）映射到固定长度的输出（数组索引），并且尽可能地使得不同的输入映射到不同的输出，减少冲突的发生。

当要访问哈希表中的一个元素时，先使用哈希函数计算关键字的哈希值（hash value），然后将哈希值作为数组的索引，直接访问数组的对应位置即可。如果哈希表中存在多个关键字的哈希值相同，称为哈希冲突（Hash collision），通常使用链表或开放寻址法（Open addressing）来解决。

哈希表的优点包括：

1. 高效的插入、查找、删除操作，时间复杂度为 O(1)；

2. 支持动态扩容，可以在运行时动态调整哈希表的大小；

3. 可以通过哈希函数来实现对元素的排序，可以用于实现高效的排序算法；

4. 可以用于实现关联数组，将任意类型的键映射到任意类型的值。

哈希表的缺点包括：

1. 哈希函数的选择很重要，不同的哈希函数可能会导致不同的哈希冲突率，而且有些哈希函数可能会受到输入数据的分布影响；

2. 如果哈希表中存在太多的冲突，会导致链表或开放寻址法的性能下降，甚至会导致哈希表的效率变得很低；

3. 如果哈希表中的元素太少或太多，也会影响哈希表的性能，需要根据实际应用场景选择适当的负载因子（load factor）。

在实际应用中，哈希表广泛用于实现各种算法和数据结构，例如：哈希集合（Hash Set）、哈希映射（Hash Map）、布隆过滤器（Bloom Filter）、一致性哈希（Consistent Hashing）等等。

<br>

### 如果哈希冲突该怎么办

哈希冲突的解决方法主要有两种：

1. 开放地址法

在开放地址法中，当哈希冲突发生时，继续寻找哈希表中的下一个空闲位置，直到找到一个空闲位置为止。这个过程可以通过线性探测、二次探测、双重哈希等方式实现。开放地址法实现简单，但在哈希表填充率较高时，会出现较多的哈希冲突，影响效率。

2. 链地址法

在链地址法中，当哈希冲突发生时，将冲突的关键字链成一个单链表，放在哈希表的对应位置上。链地址法可以很好地解决哈希冲突，但是需要额外的空间来存储链表指针，且在遍历哈希表时，需要遍历每个链表的所有结点。

<br>

### 什么是 C++头文件？

头文件（Header file）是一种包含源代码或其他头文件的文本文件，通常包含有函数和变量的声明以及其他类型的预处理指令。头文件是在程序编译期间被引入到源代码文件中的。在 C/C++中，头文件的后缀通常是.h（例如 stdio.h）。

头文件通常包含函数和变量的声明以及常量的定义，而实现则放在另一个源文件中。使用头文件可以将源代码模块化，并提高代码的可维护性和可重用性。通过头文件，我们可以在多个源文件之间共享常量、变量和函数声明，从而避免重复定义和声明，提高代码的复用性和可维护性。

在 C/C++中，标准库和第三方库通常提供头文件以供使用者引入。

<br>

### C++ Static 用法

在 C++ 中，`static` 关键字有以下几种用法：

1. 在全局变量中，表示这个变量只能在当前文件中使用，不能被其他文件访问。

```cpp
static int x; // 全局变量 x 只能在当前文件中使用，其他文件无法访问
```

2. 在函数中，表示这个函数只能在当前文件中使用，不能被其他文件调用。

```cpp
static void foo() { ... } // 函数 foo 只能在当前文件中使用，其他文件无法调用
```

3. 在类中，表示这个成员变量或成员函数是类的静态成员，即该成员不属于某个对象，而是属于整个类。

```cpp
class MyClass {
public:
    static int x;  // 静态成员变量
    static void foo() { ... } // 静态成员函数
};

int MyClass::x = 0;  // 静态成员变量需要在类外初始化

// 使用静态成员
MyClass::x = 10;
MyClass::foo();
```

静态成员变量和静态成员函数可以通过类名加作用域运算符访问，也可以通过对象名访问。但是静态成员变量和静态成员函数只有一个副本，而不是每个对象都有一份。因此，静态成员变量和静态成员函数的内存空间是在程序编译时分配的，而不是在对象创建时分配的。

4. 在函数中，表示这个变量只在函数的第一次调用时初始化，后续调用不再初始化，变量的值会保留。

```cpp
void foo() {
    static int x = 0; // x 只会在第一次调用 foo 时初始化
    x++;
    cout << x << endl;
}

foo(); // 输出 1
foo(); // 输出 2
foo(); // 输出 3
```

在这种用法下，变量的作用域仍然是在函数内部，但是该变量的生命周期会持续到整个程序结束。

### C++ 所有容器及其应用场景

C++ 中有多种容器类型，每种容器都有自己的优点和应用场景。以下是一些常见的 C++ 容器及其应用场景：

1. 数组（Array）：数组是一种简单的线性结构，存储固定大小的同类型元素，其优点是访问元素的速度快，缺点是不支持动态增长和删除操作。

2. 向量（Vector）：向量是基于数组实现的动态数组，支持快速随机访问和尾部插入元素，但在插入和删除元素时需要进行内存重新分配和拷贝操作，效率较低。

3. 链表（Linked List）：链表是一种动态数据结构，由节点（Node）和指针（Pointer）组成，支持快速插入和删除操作，但不支持快速随机访问，需要遍历整个链表才能访问到某个元素。

4. 栈（Stack）：栈是一种后进先出（LIFO）的数据结构，支持压入和弹出元素，常用于函数调用和表达式求值等场景。

5. 队列（Queue）：队列是一种先进先出（FIFO）的数据结构，支持在队尾插入元素，在队首删除元素，常用于模拟缓存、任务队列等场景。

6. 双向队列（Deque）：双向队列是一种支持在队头和队尾插入和删除元素的队列，可以看作是栈和队列的结合，常用于维护一个滑动窗口等场景。

7. 集合（Set）：集合是一种不重复元素的容器，支持插入、删除和查找元素，通常采用红黑树等数据结构实现，常用于去重、排序等场景。

8. 映射（Map）：映射是一种键值对的容器，支持按键查找和修改值，通常采用红黑树等数据结构实现，常用于存储关系数据、统计词频等场景。

9. 堆（Heap）：堆是一种支持在 O(log n) 时间内找到最小值（或最大值）的数据结构，通常采用完全二叉树实现，常用于排序、贪心算法、最短路径等场景。

10. 映射（Unordered Map）：无序映射是一种键值对的容器，支持按键查找和修改值，通常采用哈希表实现，常用于高效查找和统计等场景。

11. 集合（Unordered Set）：无序集合是一种不重复元素的容器，支持插入、删除和查找元

<br>

### 重载 overload 与重写 override 区别

重载（Overload）和重写（Override）是两个常用的面向对象编程概念，它们的主要区别如下：

1. 重载

重载是指在同一个作用域内，通过改变函数名或者参数列表，使得同名函数可以以不同的方式调用。可以认为是一种多态的表现形式，也是静态多态的一种。重载函数的返回值可以相同也可以不同，但是函数的参数列表必须不同。

例如：

```C++
int sum(int a, int b);
float sum(float a, float b);
```

在这个例子中，`sum` 函数被重载了，它分别接受两个 `int` 类型和两个 `float` 类型的参数，返回值类型也不同。

2. 重写

重写是指在派生类中重新定义基类中已有的虚函数，实现多态性，也是动态多态的一种。重写的函数名、参数列表和基类中的虚函数必须完全相同。

例如：

```C++
class Shape {
  public:
    virtual void draw() {
        cout << "Drawing a shape" << endl;
    }
};

class Circle : public Shape {
  public:
    void draw() override {
        cout << "Drawing a circle" << endl;
    }
};
```

在这个例子中，`Circle` 类从 `Shape` 类中继承了虚函数 `draw`，并重写了该函数，实现了多态性。当使用 `Circle` 对象调用 `draw` 函数时，会执行 `Circle` 中的实现。

总结：

重载是为了提供更多的方法实现，是静态多态，而重写是为了实现多态性，是动态多态。在重载函数时，函数名必须相同但参数列表不同；在重写函数时，函数名和参数列表必须与基类的虚函数完全相同，并且在派生类中需要使用 `override` 关键字来明确其重写了基类中的虚函数。

<br>

### 什么是虚函数？

在 C++中，虚函数是在基类中声明的带有 virtual 关键字的函数，它用于实现运行时多态性。  
在继承体系中，虚函数允许派生类重新定义它们继承自基类的函数，以满足它们自己的特定需求。  
当派生类实现一个虚函数时，它可以使用 override 关键字显式地指示它正在重新定义一个虚函数。

虚函数的一个重要概念是动态绑定（dynamic binding）或运行时多态性（runtime polymorphism）。  
动态绑定是指在运行时根据对象的类型决定调用哪个函数实现，而不是在编译时根据变量的类型决定调用哪个函数实现。这使得程序可以根据实际情况调用适当的函数实现，从而提高代码的灵活性和可维护性。

虚函数通常被定义为基类的公共成员，派生类可以通过继承并重载这些函数来实现多态性。  
在基类中，虚函数通常被定义为纯虚函数，它没有任何实现并且需要派生类提供实现。这种技术被称为抽象基类或接口类，它提供了一种规范化的方法来描述对象的行为，同时隐藏了实现的细节。

<br>

### 什么是纯虚函数？

纯虚函数（Pure Virtual Function）是一个在基类中声明的虚函数，没有函数体的实现，通常用于定义接口，需要子类实现其具体功能。纯虚函数用“= 0”来表示，例如：

```cpp
virtual void func() = 0;
```

纯虚函数相当于一种约束，要求子类必须实现该函数，否则子类也会成为抽象类。同时，纯虚函数也可以提供默认的实现，子类如果不实现，则使用默认实现。

<br>

###
